1.  Looping over an object using `for` statement, we should check for this condition:
    if (object.hasOwnProperty(name)) {}
2.  There is no `void` return type for javascript functions, if return nothing function would return `undefined`
3.  We cannot use reserved keywords as property name in object dot notation:
      obj.goto would fail, need to use obj["goto] in such cases
4.  We can create a new object with a linkage to object `o` through function object by: object(o). Linkage provides a simple
    inheritance machanism
5.  All objects are linked directly or in-directly to Object.prototype
6.  Make a new empty object: {}, new Object(), object(Object.prototype) --> {} is the preferred way
7.  delete arr[num] would make a hole in arr, instead if use arr.splice(num, 1) would remove the num & renumbers all the following
    array elements
8.  Functions can store key/value pairs, they can have methods becz functions are objects
9.  If the function is called with too many args, extra args are ignored; if function is called with too few args, the missing
    values are undefined. There is no implicit type checking on the arguments
10. When a function is called, it gets extra parameter along with its arguments called arguments, which is an array like object
11. We can augment basic built-ins by adding method to prototype property of that built-in, like String.prototype
12. Don't use new String(), new Boolean() and new Integer, bcz its of no use instead it jsut wraps values into object containers
13. If we think in a prototypical inheritance way, then we can leverage javascript in a better way
14. In a function body, `this` points to global object while `window` does the same in a web browser

